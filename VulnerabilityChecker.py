import requests
import socket
from urllib.parse import urlparse
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors

# List of security headers to check
SECURITY_HEADERS = ["Content-Security-Policy", "Strict-Transport-Security", "X-Frame-Options",
                    "X-XSS-Protection", "X-Content-Type-Options",
                    "Cross-Origin-Resource-Policy", "Cross-Origin-Opener-Policy",
                    "Cross-Origin-Embedder-Policy", "Public-Key-Pins", "Expect-CT",
                    "Feature-Policy", "Referrer-Policy", "X-Permitted-Cross-Domain-Policies"]

# List of common ports for checking
COMMON_PORTS = [137, 139, 445, 22, 53, 25, 3389, 80, 443, 8080, 8443, 20, 21, 23, 1433, 1434, 3306]

# Vulnerabilities associated with open ports
OPEN_PORT_VULNERABILITIES = {
    20: "FTP (File Transfer Protocol) is known for being outdated and insecure. Attackers frequently exploit it through brute-forcing passwords, anonymous authentication, cross-site scripting (XSS), and directory traversal attacks.",
    21: "FTP (File Transfer Protocol) is known for being outdated and insecure. Attackers frequently exploit it through brute-forcing passwords, anonymous authentication, cross-site scripting (XSS), and directory traversal attacks.",
    22: "SSH (Secure Shell) port is used for secure access to servers. Vulnerabilities include leaked SSH keys or brute-forcing credentials.",
    23: "Telnet is an outdated and insecure protocol, susceptible to various attacks including brute-forcing, spoofing, and credential sniffing.",
    25: "SMTP (Simple Mail Transfer Protocol) port for receiving and sending emails. Vulnerable to spoofing and spamming without proper configuration and protection.",
    53: "DNS (Domain Name System) port is particularly vulnerable to DDoS (Distributed Denial of Service) attacks and cache poisoning.",
    137: "NetBIOS/SMB (Server Message Block) ports are vulnerable to exploits like EternalBlue, allowing attackers to spread malware and brute-force login credentials.",
    139: "NetBIOS/SMB (Server Message Block) ports are vulnerable to exploits like EternalBlue, allowing attackers to spread malware and brute-force login credentials.",
    445: "SMB (Server Message Block) port is vulnerable to exploits like EternalBlue, allowing attackers to spread malware and brute-force login credentials.",
    80: "HTTP (Hypertext Transfer Protocol) port is vulnerable to various attacks including cross-site scripting (XSS), SQL injection, cross-site request forgery (CSRF), and DDoS attacks.",
    443: "HTTPS (Hypertext Transfer Protocol Secure) port is vulnerable to various attacks including cross-site scripting (XSS), SQL injection, cross-site request forgery (CSRF), and DDoS attacks.",
    8080: "HTTP (Hypertext Transfer Protocol) port is vulnerable to various attacks including cross-site scripting (XSS), SQL injection, cross-site request forgery (CSRF), and DDoS attacks.",
    8443: "HTTPS (Hypertext Transfer Protocol Secure) port is vulnerable to various attacks including cross-site scripting (XSS), SQL injection, cross-site request forgery (CSRF), and DDoS attacks.",
    1433: "SQL Server port is vulnerable to SQL injection attacks and unauthorized access.",
    1434: "SQL Server port is vulnerable to SQL injection attacks and unauthorized access.",
    3306: "MySQL port is vulnerable to SQL injection attacks and unauthorized access.",
    3389: "Remote Desktop port is vulnerable to various exploits targeting remote desktop protocols and weak user authentication, such as the BlueKeep vulnerability."
}

# Vulnerabilities associated with missing security headers
MISSING_SECURITY_HEADERS_VULNERABILITIES = {
    "Content-Security-Policy": "Missing Content-Security-Policy header can lead to various attacks such as Cross-Site Scripting (XSS), Clickjacking, and Data Injection. It helps prevent XSS attacks by specifying approved sources for content.",
    "Strict-Transport-Security": "Missing Strict-Transport-Security header can expose the application to Man-in-the-Middle (MitM) attacks and downgrade attacks. It ensures that the communication between the browser and the server occurs over HTTPS only, preventing protocol downgrade attacks.",
    "X-Frame-Options": "Missing X-Frame-Options header can make the application vulnerable to Clickjacking attacks, where an attacker can embed the application in an iframe on a malicious website and trick users into performing unintended actions.",
    "X-XSS-Protection": "Missing X-XSS-Protection header can expose the application to Cross-Site Scripting (XSS) attacks. It helps mitigate XSS attacks by enabling the browser's XSS filter.",
    "X-Content-Type-Options": "Missing X-Content-Type-Options header can make the application vulnerable to MIME sniffing attacks, where an attacker can trick the browser into executing malicious content disguised as a different content type.",
    "Cross-Origin-Resource-Policy": "Missing Cross-Origin-Resource-Policy header can lead to Cross-Origin Resource Sharing (CORS) misconfigurations, allowing unauthorized access to resources from different origins.",
    "Cross-Origin-Opener-Policy": "Missing Cross-Origin-Opener-Policy header can expose the application to Cross-Origin Window Policy (COOP) attacks, where an attacker can access sensitive information from other origins.",
    "Cross-Origin-Embedder-Policy": "Missing Cross-Origin-Embedder-Policy header can make the application vulnerable to Cross-Origin Embedder Policy (COEP) attacks, where an attacker can load the application as an embedder or a nested document in a malicious website.",
    "Public-Key-Pins": "Missing Public-Key-Pins header can expose the application to Man-in-the-Middle (MitM) attacks by allowing attackers to impersonate the server using fraudulent certificates.",
    "Expect-CT": "Missing Expect-CT header can expose the application to Certificate Transparency (CT) policy violations, allowing attackers to use fraudulent certificates without detection.",
    "Feature-Policy": "Missing Feature-Policy header can expose the application to various risks associated with allowing or restricting specific browser features. It helps prevent unauthorized access to features like geolocation, microphone, and camera.",
    "Referrer-Policy": "Missing Referrer-Policy header can leak sensitive information by sending referrer headers to external domains. It helps control how much information is included in the referrer header when navigating to external links.",
    "X-Permitted-Cross-Domain-Policies": "Missing X-Permitted-Cross-Domain-Policies header can expose the application to Cross-Domain Policy (XDP) misconfigurations, allowing unauthorized access to resources from different domains."
}

def check_security_headers(url):
    try:
        response = requests.head(url, allow_redirects=True, verify=False)
        headers = response.headers

        security_headers_data = {}
        missing_headers = []

        for header in SECURITY_HEADERS:
            if header in headers:
                security_headers_data[header] = headers[header]
            else:
                security_headers_data[header] = "MISSING"
                missing_headers.append(header)

        return security_headers_data, missing_headers

    except requests.exceptions.RequestException as e:
        print("Error occurred while retrieving security headers:", e)


def check_open_ports(target_host):
    open_ports_result = []
    for port in COMMON_PORTS:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.1)
        try:
            result = sock.connect_ex((target_host, port))
            if result == 0:
                open_ports_result.append(port)
        except socket.error as e:
            print(f"Error occurred while checking port {port}: {e}")
        finally:
            sock.close()
    return open_ports_result


def generate_pdf_report(user_input, target_host, security_headers_data, missing_headers, open_ports):
    filename = f"Vulnerability_Report_{user_input.replace('/', '_').replace(':', '_')}.pdf"
    doc = SimpleDocTemplate(filename, pagesize=letter)
    styles = getSampleStyleSheet()
    style_heading = styles["Heading1"]
    style_body = styles["BodyText"]

    content = []

    content.append(Paragraph(f"<font color=blue><b>Vulnerability Report for {user_input}</b></font>", style_heading))
    content.append(Spacer(1, 12))

    content.append(Paragraph(f"<b>Target Host:</b> {target_host}", style_body))
    content.append(Spacer(1, 12))

    content.append(Paragraph("<font color=blue><b>Security Headers Check:</b></font>", style_heading))
    for header, value in security_headers_data.items():
        content.append(Paragraph(f"- <font color=blue><b>{header}</b></font>: {value}", style_body))
    content.append(Spacer(1, 12))

    if missing_headers:
        content.append(Paragraph("<font color=blue><b>Security Header Issues:</b></font>", style_heading))
        for header in missing_headers:
            content.append(Paragraph(f"- <font color=blue><b>{header}</b></font> is missing.", style_body))
            content.append(Paragraph(f"{MISSING_SECURITY_HEADERS_VULNERABILITIES[header]}", style_body))
        content.append(Spacer(1, 12))

    content.append(Paragraph("<font color=blue><b>Open Ports Check:</b></font>", style_heading))
    for port in open_ports:
        content.append(Paragraph(f"- <font color=blue><b>Port {port}</b></font>: OPEN", style_body))

        if port in OPEN_PORT_VULNERABILITIES:
            content.append(Paragraph(f"{OPEN_PORT_VULNERABILITIES[port]}", style_body))
        else:
            content.append(Paragraph("No specific vulnerabilities associated with this port.", style_body))

    doc.build(content)
    print(f"PDF report generated: {filename}")


def main():
    user_input = input("Enter the website URL or IP address: ")

    if not user_input.startswith(("http://", "https://")):
        user_input = "http://" + user_input

    parsed_input = urlparse(user_input)
    target_host = parsed_input.hostname or user_input

    if target_host:
        print(f"Target Host: {target_host}")
        security_headers_data, missing_headers = check_security_headers(user_input)
        open_ports = check_open_ports(target_host)

        generate_pdf_report(user_input, target_host, security_headers_data, missing_headers, open_ports)
    else:
        print("Invalid URL or IP address provided.")


if __name__ == "__main__":
    main()
